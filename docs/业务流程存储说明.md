# 代码流程存储说明

## 核心设计理念

本系统采用创新的"数据库驱动业务逻辑"架构，代码流程存储在**数据库**中，而不是传统的文件系统。

### 设计优势

1. **热更新**：修改业务逻辑无需重启服务
2. **版本控制**：每次修改都有版本记录，支持回滚
3. **动态管理**：通过API即可创建、修改、删除代码流程
4. **权限控制**：只有管理员可以修改业务逻辑
5. **执行隔离**：VM沙箱确保代码安全执行

## 数据表结构

### code_flows（代码流程表）

```sql
CREATE TABLE `code_flows` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `code` varchar(100) NOT NULL COMMENT '流程编码',
  `name` varchar(200) NOT NULL COMMENT '流程名称',
  `category` varchar(50) DEFAULT NULL COMMENT '流程分类',
  `description` text COMMENT '流程描述',
  `code_content` text NOT NULL COMMENT '流程代码',
  `input_schema` json DEFAULT NULL COMMENT '输入参数定义',
  `output_schema` json DEFAULT NULL COMMENT '输出结果定义',
  `version` int(11) DEFAULT 1 COMMENT '版本号',
  `status` int(11) DEFAULT 1 COMMENT '状态: 0-禁用 1-启用',
  `created_by` int(11) DEFAULT NULL COMMENT '创建人ID',
  `updated_by` int(11) DEFAULT NULL COMMENT '更新人ID',
  `remark` text COMMENT '备注',
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_code` (`code`),
  KEY `idx_category` (`category`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='代码流程表';
```

## 代码流程格式

代码流程存储在 `code_content` 字段中，格式如下：

```javascript
// context 包含以下属性：
// - repositories: 所有数据访问仓储
// - dataSource: TypeORM DataSource，用于事务
// - params: 输入参数
// - user: 当前用户信息

const { repositories, params, user } = context;
const { customerRepository } = repositories;

// 业务逻辑
const customer = customerRepository.create({
  name: params.name,
  mobile: params.mobile,
  address: params.address,
  status: 'lead',
  salesId: user.id,
});

await customerRepository.save(customer);

// 返回结果
return {
  success: true,
  data: customer,
  message: '客户创建成功'
};
```

**注意**：
1. 代码会在沙箱环境（VM模块）中执行
2. 有30秒的执行超时限制
3. 只能访问 context 中提供的对象和方法
4. 支持 async/await

## 执行流程

1. **存储**：通过 API 将业务流程代码存入数据库
2. **加载**：BusinessExecutorService 从数据库读取代码
3. **编译**：使用 VM 模块编译代码为可执行函数
4. **缓存**：编译后的函数会被缓存，基于 updatedAt 时间戳
5. **执行**：传入 context 对象执行业务逻辑
6. **返回**：返回执行结果

## API 接口

### 1. 执行业务流程

```http
POST /api/business/execute/:flowCode
Authorization: Bearer <token>

{
  "params": {
    "name": "张三",
    "mobile": "13800138000",
    "address": "北京市朝阳区"
  }
}
```

### 2. 列出所有流程

```http
GET /api/business/flows
Authorization: Bearer <token>
```

### 3. 创建业务流程（仅管理员）

```http
POST /api/business/flows
Authorization: Bearer <token>

{
  "code": "01_客户录入",
  "name": "客户录入",
  "category": "客户管理",
  "description": "创建新客户记录",
  "code_content": "const { repositories, params } = context; ...",
  "version": 1
}
```

### 4. 更新业务流程（仅管理员）

```http
PUT /api/business/flows/:flowCode
Authorization: Bearer <token>

{
  "name": "客户录入（更新）",
  "code_content": "...",
  "version": 2
}
```

### 5. 禁用业务流程（仅管理员）

```http
DELETE /api/business/flows/:flowCode
Authorization: Bearer <token>
```

### 6. 清除流程缓存（仅管理员）

```http
POST /api/business/flows/:flowCode/clear-cache
Authorization: Bearer <token>
```

## Context 对象详解

执行业务流程时，会传入一个 `context` 对象，包含以下属性：

### repositories

所有数据访问仓储对象：

- `userRepository`: Repository<User>
- `customerRepository`: Repository<Customer>
- `customerFollowRepository`: Repository<CustomerFollow>
- `materialRepository`: Repository<Material>
- `orderRepository`: Repository<Order>
- `orderItemRepository`: Repository<OrderItem>
- `paymentRepository`: Repository<Payment>
- `projectRepository`: Repository<Project>
- `fileRepository`: Repository<File>

### dataSource

TypeORM 的 DataSource 对象，用于执行事务：

```javascript
const { dataSource } = context;

await dataSource.transaction(async (manager) => {
  // 事务内的操作
  await manager.save(entity1);
  await manager.save(entity2);
});
```

### params

输入参数，由调用方传入。

### user

当前登录用户信息（从JWT token中解析）：

```javascript
{
  id: 1,
  username: 'admin',
  name: '管理员',
  role: 'admin',
  companyId: 1,
  departmentId: 1
}
```

## 示例业务流程

### 01_客户录入

```javascript
const { repositories, params, user } = context;
const { customerRepository } = repositories;

// 验证参数
if (!params.name || !params.mobile) {
  throw new Error('客户姓名和手机号不能为空');
}

// 检查手机号是否已存在
const existingCustomer = await customerRepository.findOne({
  where: { mobile: params.mobile }
});

if (existingCustomer) {
  throw new Error('该手机号已存在');
}

// 创建客户
const customer = customerRepository.create({
  name: params.name,
  mobile: params.mobile,
  address: params.address,
  area: params.area,
  source: params.source,
  status: 'lead',
  salesId: user.id,
});

await customerRepository.save(customer);

return {
  success: true,
  message: '客户录入成功',
  data: customer
};
```

### 02_添加跟进

```javascript
const { repositories, params, user, dataSource } = context;
const { customerRepository, customerFollowRepository } = repositories;

// 验证客户是否存在
const customer = await customerRepository.findOne({
  where: { id: params.customerId }
});

if (!customer) {
  throw new Error('客户不存在');
}

// 使用事务创建跟进记录
await dataSource.transaction(async (manager) => {
  // 创建跟进记录
  const follow = customerFollowRepository.create({
    customerId: params.customerId,
    userId: user.id,
    type: params.type,
    content: params.content,
    nextFollowAt: params.nextFollowAt,
  });
  
  await manager.save(follow);
  
  // 根据跟进类型更新客户状态
  if (params.type === 'measure' && customer.status === 'lead') {
    customer.status = 'measured';
    customer.measuredAt = new Date();
    await manager.save(customer);
  }
});

return {
  success: true,
  message: '跟进记录已添加'
};
```

## 安全考虑

1. **沙箱执行**：代码在 VM 沙箱中执行，限制了可访问的全局对象
2. **超时控制**：30秒执行超时，防止死循环
3. **权限控制**：只有管理员可以创建/修改/删除业务流程
4. **状态控制**：禁用的流程无法执行
5. **审计日志**：记录创建人和更新人

## 优势

1. **热更新**：修改代码后立即生效，无需重启服务
2. **版本管理**：可以保存多个版本，支持回滚
3. **灵活性**：可以通过管理后台动态创建和修改业务逻辑
4. **隔离性**：业务逻辑与框架代码分离
5. **可追溯**：所有修改都有记录

## 最佳实践

1. **代码规范**：保持代码简洁，单一职责
2. **错误处理**：使用 try-catch 捕获异常
3. **参数验证**：在业务逻辑开始前验证所有参数
4. **事务使用**：涉及多个数据库操作时使用事务
5. **返回格式**：统一返回格式 `{ success, message, data }`
6. **版本升级**：修改代码时增加版本号
7. **测试验证**：更新后及时测试验证功能

